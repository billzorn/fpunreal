(FPCore (theta)
        :name gsl_sf_angle_restrict_symm
        :precision binary64
        :spec (fmod theta (* 2 PI))
        (let ([P1 (* 4 (cast 7.8539812564849853515625e-01 binary64))]
              [P2 (* 4 (cast 3.7748947079307981766760e-08 binary64))]
              [P3 (* 4 (cast 2.6951514290790594840552e-15 binary64))])
          (let ([TwoPi (* 2 (+ P1 (+ P2 P3)))])
            (let ([y (* 2 (floor (/ theta TwoPi)))])
              (let ([r (- (- (- theta (* y P1)) (* y P2)) (* y P3))])
                (if (> r PI) (- (- (- r (* 2 P1)) (* 2 P2)) (* 2 P3))
                    (if (< r (- PI)) (+ (+ (+ r (* 2 P1)) (* 2 P2)) (* 2 P3))
                        r)))))))

(FPCore (theta)
        :name gsl_sf_angle_restrict_symm
        :precision binary64
        :spec (fmod theta (* 2 PI))
        (let ([P1 (cast PI binary32_RTZ)])
          (let ([P2 (cast (- (cast PI real) P1) binary32_RTZ)])
            (let ([P3 (cast (- (cast PI real) (cast (+ P1 P2) binary64)))])
              (let ([TwoPi (* 2 (+ P1 (+ P2 P3)))])
                (let ([y (* 2 (floor (/ theta TwoPi)))])
                  (let ([r (- (- (- theta (* y P1)) (* y P2)) (* y P3))])
                    (if (> r PI) (- (- (- r (* 2 P1)) (* 2 P2)) (* 2 P3))
                        (if (< r (- PI)) (+ (+ (+ r (* 2 P1)) (* 2 P2)) (* 2 P3))
                            r)))))))))

(FPCore (x)
        :name round
        :precision binary64
        :spec (round x)
        (let ([n 6755399441055744])
          (cast (- (cast (+ x n) binary64) n) binary64)))

(FPCore (x)
        :name abs_err_binary16
        :precision real
        (let ([x^ (cast x binary16)])
          (fabs (- x x^))))

(FPCore (x^)
        :name abs_err
        :precision binary16
        (let ([x (cast x^ real)])
          (cast (fabs (cast (- x x^) real) real)))
